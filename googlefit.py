# -*- coding: utf-8 -*-
"""googleFit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sgr08KrKQ-aQMvmxnXMGpFGRxvMqF8Fd
"""
import os
import json
import pickle
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from google.auth.transport.requests import Request

SCOPES = ['https://www.googleapis.com/auth/fitness.activity.read']
CREDENTIALS_FILE = 'client_secrets.json'
TOKEN_FILE = 'token.pkl'
TOKEN_URI = "https://oauth2.googleapis.com/token"

def save_token(creds):
    with open(TOKEN_FILE, 'wb') as f:
        pickle.dump(creds, f)

def load_token():
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, 'rb') as f:
            return pickle.load(f)
    return None

def creds_from_secrets_env():
    gclient_json = os.getenv('GCLIENT_JSON')
    refresh_token = os.getenv('GREFRESH_TOKEN')
    if not (gclient_json and refresh_token):
        return None

    cfg = json.loads(gclient_json)
    client_info = cfg.get('installed') or cfg.get('web') or {}
    client_id = client_info.get('client_id')
    client_secret = client_info.get('client_secret')
    if not (client_id and client_secret):
        return None

    creds = Credentials(
        token=None,
        refresh_token=refresh_token,
        token_uri=TOKEN_URI,
        client_id=client_id,
        client_secret=client_secret,
        scopes=SCOPES
    )
    creds.refresh(Request())  # get access token
    return creds

def interactive_flow():
    if not os.path.exists(CREDENTIALS_FILE):
        return None
    flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
    return flow.run_console()

# 1) Try existing token
credentials = load_token()

# 2) If no valid token, try env-based non-interactive (CI)
if not credentials or not getattr(credentials, "valid", False):
    if credentials and getattr(credentials, "expired", False) and getattr(credentials, "refresh_token", None):
        credentials.refresh(Request())
    else:
        credentials = creds_from_secrets_env()

# 3) Fallback to interactive local flow
if not credentials or not getattr(credentials, "valid", False):
    credentials = interactive_flow()

if not credentials:
    raise SystemExit("No credentials available. Provide token.pkl, GCLIENT_JSON + GREFRESH_TOKEN, or client_secrets.json for interactive auth.")

# Save token for future runs (safe in local dev / ephemeral CI workspace)
save_token(credentials)

# Build service
service = build('fitness', 'v1', credentials=credentials)
print("OAuth credentials ready.")

import datetime
from datetime import timedelta

# Define the data source for step counts.
# This is a commonly used data source for steps from various fitness apps.
STEP_DATA_SOURCE = "derived:com.google.step_count.delta:com.google.android.gms:estimated_steps"

end_time = datetime.datetime.now()
start_time = end_time - datetime.timedelta(days=7)

# Convert timestamps to nanoseconds, which is required by the Google Fit API.
start_time_ns = int(start_time.timestamp() * 1e9)
end_time_ns = int(end_time.timestamp() * 1e9)

# Fetch the step data from the Google Fit API.
results = service.users().dataSources().datasets().get(
    userId='me',
    dataSourceId=STEP_DATA_SOURCE,
    datasetId=f'{start_time_ns}-{end_time_ns}'
).execute()

print(f"Step data for the last 7 days:")

dtArr = []
stepsArr = []

if 'point' in results:
    for point in results['point']:
        start_time_point = datetime.datetime.fromtimestamp(int(point['startTimeNanos']) / 1e9).replace(microsecond=0)
        end_time_point = datetime.datetime.fromtimestamp(int(point['endTimeNanos']) / 1e9).replace(microsecond=0) 
        step_count = point['value'][0]['intVal']
        # print(f"  From {start_time_point} to {end_time_point}: {step_count} steps")
        dtArr.append(start_time_point)
        stepsArr.append(step_count)
else:
    print("No step data found for the specified time range.")

dtArr

import pandas as pd
df = pd.DataFrame()

df['Datetime'] = dtArr

df['Year'] = df['Datetime'].dt.year
df['Month'] = df['Datetime'].dt.month
df['Day'] = df['Datetime'].dt.day
df['Hour'] = df['Datetime'].dt.hour
df['Minute'] = df['Datetime'].dt.minute
df['Week'] = df['Datetime'].dt.isocalendar().week
df['Day of week'] = df['Datetime'].dt.strftime("%A")
# /////////Adding steps//////////////
df['Steps'] = stepsArr


df.to_csv('stepsData.csv',index=False)

df.groupby(['Month','Day'])['Steps'].sum()

# ///////// Datetime is stored in UTC///////////

dfGroupM = df.groupby(['Month'])['Steps'].sum()
dfGroupW = df.groupby(['Week'])['Steps'].sum()
dfGroupD = df.groupby(['Day'])['Steps'].sum()


day_steps = dfGroupD.iloc[-1]
week_steps = dfGroupW.iloc[-1]
month_steps = dfGroupM.iloc[-1]

message = (
    f"Hi! Here's your step summary:\n\n"
    f"ðŸ“… Today ({df['Datetime'].dt.date.iloc[-1]}): {day_steps:,} steps\n"
    f"ðŸ“… This Week: {week_steps:,} steps\n"
    f"ðŸ“† This Month ({df['Datetime'].dt.strftime('%b').iloc[-1]}): {month_steps:,} steps\n\n"
    "Keep moving and stay healthy! ðŸ’ª"
)

print(message)

